import He, { createContext as yt, useState as F, useRef as J, useEffect as v, useMemo as q, useContext as _t, useCallback as Ee } from "react";
import { Presence3D as Rt, AutodeskPin as Ct } from "@superviz/autodesk-viewer-plugin";
import Pt, { ParticipantEvent as K, Comments as wt, FormElements as At, MousePointers as St, Realtime as Ot, RealtimeComponentEvent as It, VideoConference as Dt, MeetingEvent as x, FrameEvent as Lt, WhoIsOnline as jt, CanvasPin as xt, HTMLPin as Nt, RealtimeComponentState as Mt } from "@superviz/sdk";
import { isEqual as Be } from "lodash";
import { Presence3D as Ft, MatterportPin as kt } from "@superviz/matterport-plugin";
import { Presence3D as $t, ThreeJsPin as Vt } from "@superviz/threejs-plugin";
var we = { exports: {} }, ce = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ge;
function zt() {
  return Ge || (Ge = 1, process.env.NODE_ENV !== "production" && function() {
    var t = He, o = Symbol.for("react.element"), n = Symbol.for("react.portal"), i = Symbol.for("react.fragment"), s = Symbol.for("react.strict_mode"), d = Symbol.for("react.profiler"), l = Symbol.for("react.provider"), f = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), m = Symbol.for("react.suspense_list"), g = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), C = Symbol.for("react.offscreen"), _ = Symbol.iterator, w = "@@iterator";
    function z(e) {
      if (e === null || typeof e != "object")
        return null;
      var r = _ && e[_] || e[w];
      return typeof r == "function" ? r : null;
    }
    var T = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function S(e) {
      {
        for (var r = arguments.length, a = new Array(r > 1 ? r - 1 : 0), p = 1; p < r; p++)
          a[p - 1] = arguments[p];
        ee("error", e, a);
      }
    }
    function ee(e, r, a) {
      {
        var p = T.ReactDebugCurrentFrame, R = p.getStackAddendum();
        R !== "" && (r += "%s", a = a.concat([R]));
        var P = a.map(function(h) {
          return String(h);
        });
        P.unshift("Warning: " + r), Function.prototype.apply.call(console[e], console, P);
      }
    }
    var te = !1, k = !1, N = !1, U = !1, Q = !1, L;
    L = Symbol.for("react.module.reference");
    function V(e) {
      return !!(typeof e == "string" || typeof e == "function" || e === i || e === d || Q || e === s || e === c || e === m || U || e === C || te || k || N || typeof e == "object" && e !== null && (e.$$typeof === y || e.$$typeof === g || e.$$typeof === l || e.$$typeof === f || e.$$typeof === u || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      e.$$typeof === L || e.getModuleId !== void 0));
    }
    function G(e, r, a) {
      var p = e.displayName;
      if (p)
        return p;
      var R = r.displayName || r.name || "";
      return R !== "" ? a + "(" + R + ")" : a;
    }
    function H(e) {
      return e.displayName || "Context";
    }
    function j(e) {
      if (e == null)
        return null;
      if (typeof e.tag == "number" && S("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof e == "function")
        return e.displayName || e.name || null;
      if (typeof e == "string")
        return e;
      switch (e) {
        case i:
          return "Fragment";
        case n:
          return "Portal";
        case d:
          return "Profiler";
        case s:
          return "StrictMode";
        case c:
          return "Suspense";
        case m:
          return "SuspenseList";
      }
      if (typeof e == "object")
        switch (e.$$typeof) {
          case f:
            var r = e;
            return H(r) + ".Consumer";
          case l:
            var a = e;
            return H(a._context) + ".Provider";
          case u:
            return G(e, e.render, "ForwardRef");
          case g:
            var p = e.displayName || null;
            return p !== null ? p : j(e.type) || "Memo";
          case y: {
            var R = e, P = R._payload, h = R._init;
            try {
              return j(h(P));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var M = Object.assign, X = 0, b, W, B, re, ne, se, Ae;
    function Se() {
    }
    Se.__reactDisabledLog = !0;
    function qe() {
      {
        if (X === 0) {
          b = console.log, W = console.info, B = console.warn, re = console.error, ne = console.group, se = console.groupCollapsed, Ae = console.groupEnd;
          var e = {
            configurable: !0,
            enumerable: !0,
            value: Se,
            writable: !0
          };
          Object.defineProperties(console, {
            info: e,
            log: e,
            warn: e,
            error: e,
            group: e,
            groupCollapsed: e,
            groupEnd: e
          });
        }
        X++;
      }
    }
    function Xe() {
      {
        if (X--, X === 0) {
          var e = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: M({}, e, {
              value: b
            }),
            info: M({}, e, {
              value: W
            }),
            warn: M({}, e, {
              value: B
            }),
            error: M({}, e, {
              value: re
            }),
            group: M({}, e, {
              value: ne
            }),
            groupCollapsed: M({}, e, {
              value: se
            }),
            groupEnd: M({}, e, {
              value: Ae
            })
          });
        }
        X < 0 && S("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Te = T.ReactCurrentDispatcher, he;
    function de(e, r, a) {
      {
        if (he === void 0)
          try {
            throw Error();
          } catch (R) {
            var p = R.stack.trim().match(/\n( *(at )?)/);
            he = p && p[1] || "";
          }
        return `
` + he + e;
      }
    }
    var be = !1, pe;
    {
      var Ze = typeof WeakMap == "function" ? WeakMap : Map;
      pe = new Ze();
    }
    function Oe(e, r) {
      if (!e || be)
        return "";
      {
        var a = pe.get(e);
        if (a !== void 0)
          return a;
      }
      var p;
      be = !0;
      var R = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var P;
      P = Te.current, Te.current = null, qe();
      try {
        if (r) {
          var h = function() {
            throw Error();
          };
          if (Object.defineProperty(h.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(h, []);
            } catch (Z) {
              p = Z;
            }
            Reflect.construct(e, [], h);
          } else {
            try {
              h.call();
            } catch (Z) {
              p = Z;
            }
            e.call(h.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Z) {
            p = Z;
          }
          e();
        }
      } catch (Z) {
        if (Z && p && typeof Z.stack == "string") {
          for (var E = Z.stack.split(`
`), $ = p.stack.split(`
`), O = E.length - 1, D = $.length - 1; O >= 1 && D >= 0 && E[O] !== $[D]; )
            D--;
          for (; O >= 1 && D >= 0; O--, D--)
            if (E[O] !== $[D]) {
              if (O !== 1 || D !== 1)
                do
                  if (O--, D--, D < 0 || E[O] !== $[D]) {
                    var Y = `
` + E[O].replace(" at new ", " at ");
                    return e.displayName && Y.includes("<anonymous>") && (Y = Y.replace("<anonymous>", e.displayName)), typeof e == "function" && pe.set(e, Y), Y;
                  }
                while (O >= 1 && D >= 0);
              break;
            }
        }
      } finally {
        be = !1, Te.current = P, Xe(), Error.prepareStackTrace = R;
      }
      var ie = e ? e.displayName || e.name : "", Ue = ie ? de(ie) : "";
      return typeof e == "function" && pe.set(e, Ue), Ue;
    }
    function Qe(e, r, a) {
      return Oe(e, !1);
    }
    function et(e) {
      var r = e.prototype;
      return !!(r && r.isReactComponent);
    }
    function me(e, r, a) {
      if (e == null)
        return "";
      if (typeof e == "function")
        return Oe(e, et(e));
      if (typeof e == "string")
        return de(e);
      switch (e) {
        case c:
          return de("Suspense");
        case m:
          return de("SuspenseList");
      }
      if (typeof e == "object")
        switch (e.$$typeof) {
          case u:
            return Qe(e.render);
          case g:
            return me(e.type, r, a);
          case y: {
            var p = e, R = p._payload, P = p._init;
            try {
              return me(P(R), r, a);
            } catch {
            }
          }
        }
      return "";
    }
    var ve = Object.prototype.hasOwnProperty, Ie = {}, De = T.ReactDebugCurrentFrame;
    function ge(e) {
      if (e) {
        var r = e._owner, a = me(e.type, e._source, r ? r.type : null);
        De.setExtraStackFrame(a);
      } else
        De.setExtraStackFrame(null);
    }
    function tt(e, r, a, p, R) {
      {
        var P = Function.call.bind(ve);
        for (var h in e)
          if (P(e, h)) {
            var E = void 0;
            try {
              if (typeof e[h] != "function") {
                var $ = Error((p || "React class") + ": " + a + " type `" + h + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof e[h] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw $.name = "Invariant Violation", $;
              }
              E = e[h](r, h, p, a, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (O) {
              E = O;
            }
            E && !(E instanceof Error) && (ge(R), S("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", p || "React class", a, h, typeof E), ge(null)), E instanceof Error && !(E.message in Ie) && (Ie[E.message] = !0, ge(R), S("Failed %s type: %s", a, E.message), ge(null));
          }
      }
    }
    var rt = Array.isArray;
    function ye(e) {
      return rt(e);
    }
    function nt(e) {
      {
        var r = typeof Symbol == "function" && Symbol.toStringTag, a = r && e[Symbol.toStringTag] || e.constructor.name || "Object";
        return a;
      }
    }
    function ot(e) {
      try {
        return Le(e), !1;
      } catch {
        return !0;
      }
    }
    function Le(e) {
      return "" + e;
    }
    function je(e) {
      if (ot(e))
        return S("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", nt(e)), Le(e);
    }
    var ue = T.ReactCurrentOwner, it = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, xe, Ne, _e;
    _e = {};
    function at(e) {
      if (ve.call(e, "ref")) {
        var r = Object.getOwnPropertyDescriptor(e, "ref").get;
        if (r && r.isReactWarning)
          return !1;
      }
      return e.ref !== void 0;
    }
    function st(e) {
      if (ve.call(e, "key")) {
        var r = Object.getOwnPropertyDescriptor(e, "key").get;
        if (r && r.isReactWarning)
          return !1;
      }
      return e.key !== void 0;
    }
    function ut(e, r) {
      if (typeof e.ref == "string" && ue.current && r && ue.current.stateNode !== r) {
        var a = j(ue.current.type);
        _e[a] || (S('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', j(ue.current.type), e.ref), _e[a] = !0);
      }
    }
    function ct(e, r) {
      {
        var a = function() {
          xe || (xe = !0, S("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", r));
        };
        a.isReactWarning = !0, Object.defineProperty(e, "key", {
          get: a,
          configurable: !0
        });
      }
    }
    function lt(e, r) {
      {
        var a = function() {
          Ne || (Ne = !0, S("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", r));
        };
        a.isReactWarning = !0, Object.defineProperty(e, "ref", {
          get: a,
          configurable: !0
        });
      }
    }
    var ft = function(e, r, a, p, R, P, h) {
      var E = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: o,
        // Built-in properties that belong on the element
        type: e,
        key: r,
        ref: a,
        props: h,
        // Record the component responsible for creating this element.
        _owner: P
      };
      return E._store = {}, Object.defineProperty(E._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(E, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: p
      }), Object.defineProperty(E, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: R
      }), Object.freeze && (Object.freeze(E.props), Object.freeze(E)), E;
    };
    function dt(e, r, a, p, R) {
      {
        var P, h = {}, E = null, $ = null;
        a !== void 0 && (je(a), E = "" + a), st(r) && (je(r.key), E = "" + r.key), at(r) && ($ = r.ref, ut(r, R));
        for (P in r)
          ve.call(r, P) && !it.hasOwnProperty(P) && (h[P] = r[P]);
        if (e && e.defaultProps) {
          var O = e.defaultProps;
          for (P in O)
            h[P] === void 0 && (h[P] = O[P]);
        }
        if (E || $) {
          var D = typeof e == "function" ? e.displayName || e.name || "Unknown" : e;
          E && ct(h, D), $ && lt(h, D);
        }
        return ft(e, E, $, R, p, ue.current, h);
      }
    }
    var Re = T.ReactCurrentOwner, Me = T.ReactDebugCurrentFrame;
    function oe(e) {
      if (e) {
        var r = e._owner, a = me(e.type, e._source, r ? r.type : null);
        Me.setExtraStackFrame(a);
      } else
        Me.setExtraStackFrame(null);
    }
    var Ce;
    Ce = !1;
    function Pe(e) {
      return typeof e == "object" && e !== null && e.$$typeof === o;
    }
    function Fe() {
      {
        if (Re.current) {
          var e = j(Re.current.type);
          if (e)
            return `

Check the render method of \`` + e + "`.";
        }
        return "";
      }
    }
    function pt(e) {
      {
        if (e !== void 0) {
          var r = e.fileName.replace(/^.*[\\\/]/, ""), a = e.lineNumber;
          return `

Check your code at ` + r + ":" + a + ".";
        }
        return "";
      }
    }
    var ke = {};
    function mt(e) {
      {
        var r = Fe();
        if (!r) {
          var a = typeof e == "string" ? e : e.displayName || e.name;
          a && (r = `

Check the top-level render call using <` + a + ">.");
        }
        return r;
      }
    }
    function $e(e, r) {
      {
        if (!e._store || e._store.validated || e.key != null)
          return;
        e._store.validated = !0;
        var a = mt(r);
        if (ke[a])
          return;
        ke[a] = !0;
        var p = "";
        e && e._owner && e._owner !== Re.current && (p = " It was passed a child from " + j(e._owner.type) + "."), oe(e), S('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', a, p), oe(null);
      }
    }
    function Ve(e, r) {
      {
        if (typeof e != "object")
          return;
        if (ye(e))
          for (var a = 0; a < e.length; a++) {
            var p = e[a];
            Pe(p) && $e(p, r);
          }
        else if (Pe(e))
          e._store && (e._store.validated = !0);
        else if (e) {
          var R = z(e);
          if (typeof R == "function" && R !== e.entries)
            for (var P = R.call(e), h; !(h = P.next()).done; )
              Pe(h.value) && $e(h.value, r);
        }
      }
    }
    function vt(e) {
      {
        var r = e.type;
        if (r == null || typeof r == "string")
          return;
        var a;
        if (typeof r == "function")
          a = r.propTypes;
        else if (typeof r == "object" && (r.$$typeof === u || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        r.$$typeof === g))
          a = r.propTypes;
        else
          return;
        if (a) {
          var p = j(r);
          tt(a, e.props, "prop", p, e);
        } else if (r.PropTypes !== void 0 && !Ce) {
          Ce = !0;
          var R = j(r);
          S("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", R || "Unknown");
        }
        typeof r.getDefaultProps == "function" && !r.getDefaultProps.isReactClassApproved && S("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function gt(e) {
      {
        for (var r = Object.keys(e.props), a = 0; a < r.length; a++) {
          var p = r[a];
          if (p !== "children" && p !== "key") {
            oe(e), S("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", p), oe(null);
            break;
          }
        }
        e.ref !== null && (oe(e), S("Invalid attribute `ref` supplied to `React.Fragment`."), oe(null));
      }
    }
    function ze(e, r, a, p, R, P) {
      {
        var h = V(e);
        if (!h) {
          var E = "";
          (e === void 0 || typeof e == "object" && e !== null && Object.keys(e).length === 0) && (E += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var $ = pt(R);
          $ ? E += $ : E += Fe();
          var O;
          e === null ? O = "null" : ye(e) ? O = "array" : e !== void 0 && e.$$typeof === o ? (O = "<" + (j(e.type) || "Unknown") + " />", E = " Did you accidentally export a JSX literal instead of a component?") : O = typeof e, S("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", O, E);
        }
        var D = dt(e, r, a, R, P);
        if (D == null)
          return D;
        if (h) {
          var Y = r.children;
          if (Y !== void 0)
            if (p)
              if (ye(Y)) {
                for (var ie = 0; ie < Y.length; ie++)
                  Ve(Y[ie], e);
                Object.freeze && Object.freeze(Y);
              } else
                S("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Ve(Y, e);
        }
        return e === i ? gt(D) : vt(D), D;
      }
    }
    function Et(e, r, a) {
      return ze(e, r, a, !0);
    }
    function Tt(e, r, a) {
      return ze(e, r, a, !1);
    }
    var ht = Tt, bt = Et;
    ce.Fragment = i, ce.jsx = ht, ce.jsxs = bt;
  }()), ce;
}
var le = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var We;
function Ut() {
  if (We)
    return le;
  We = 1;
  var t = He, o = Symbol.for("react.element"), n = Symbol.for("react.fragment"), i = Object.prototype.hasOwnProperty, s = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, d = { key: !0, ref: !0, __self: !0, __source: !0 };
  function l(f, u, c) {
    var m, g = {}, y = null, C = null;
    c !== void 0 && (y = "" + c), u.key !== void 0 && (y = "" + u.key), u.ref !== void 0 && (C = u.ref);
    for (m in u)
      i.call(u, m) && !d.hasOwnProperty(m) && (g[m] = u[m]);
    if (f && f.defaultProps)
      for (m in u = f.defaultProps, u)
        g[m] === void 0 && (g[m] = u[m]);
    return { $$typeof: o, type: f, key: y, ref: C, props: g, _owner: s.current };
  }
  return le.Fragment = n, le.jsx = l, le.jsxs = l, le;
}
process.env.NODE_ENV === "production" ? we.exports = Ut() : we.exports = zt();
var A = we.exports;
const Ye = (t) => ({
  [K.JOINED]: t.onParticipantJoined,
  [K.LEFT]: t.onParticipantLeft,
  [K.LIST_UPDATED]: t.onParticipantListUpdated,
  [K.LOCAL_JOINED]: t.onParticipantLocalJoined,
  [K.LOCAL_LEFT]: t.onParticipantLocalLeft,
  [K.LOCAL_UPDATED]: t.onParticipantLocalUpdated
}), Ke = yt({
  hasProvider: !1,
  room: null
});
function I(t) {
  const { hasProvider: o, ...n } = _t(Ke);
  return v(() => {
    o || console.error("[SuperViz] You need to wrap your component with SuperVizRoomProvider");
  }, [o]), t ? {
    ...n,
    component: n.activeComponents[t]
  } : n;
}
function Zt(t) {
  const {
    roomId: o,
    group: n,
    debug: i,
    children: s,
    environment: d,
    participant: l,
    developerKey: f,
    customColors: u,
    onParticipantJoined: c,
    onParticipantLeft: m,
    onParticipantListUpdated: g,
    onParticipantLocalJoined: y,
    onParticipantLocalLeft: C,
    onParticipantLocalUpdated: _
  } = t, [w, z] = F(!1), [T, S] = F(null), [ee, te] = F(null), k = J(
    {}
  ), N = J(!1);
  v(() => {
    if (!(!Q || w))
      return N.current || Q(), () => {
        !L || !w || L();
      };
  }, []), v(() => {
    const b = Ye(t);
    !T || Be(ee, b) || U(T, t);
  }, [
    c,
    m,
    g,
    y,
    C,
    _,
    T
  ]), v(() => {
    w && (T == null || T.unsubscribe(K.LOCAL_UPDATED), T == null || T.subscribe(K.LOCAL_UPDATED, H));
  }, [T, k]);
  function U(b, W) {
    const B = Ye(W);
    Object.entries(B).forEach(([re, ne]) => {
      const se = W[re];
      (!ne && se || ne !== se) && b.unsubscribe(re), ne && b.subscribe(re, ne);
    }), te(B);
  }
  async function Q() {
    if (w || T) {
      console.log("[SuperViz] Room already started");
      return;
    }
    try {
      N.current = !0;
      const b = await Pt(f, {
        participant: l,
        roomId: o,
        group: n,
        environment: d,
        debug: i,
        customColors: u
      });
      U(b, t), S(b), b.subscribe(K.LOCAL_UPDATED, H), b.subscribe(K.LOCAL_JOINED, j), b.subscribe(K.LOCAL_LEFT, M);
    } catch (b) {
      N.current = !1, console.error("[SuperViz] Error starting room", b);
    }
    N.current = !1;
  }
  function L() {
    if (!T) {
      console.error(
        "[SuperViz] Room not started yet, you need to start the room before stopping it"
      );
      return;
    }
    T.destroy(), k.current = {}, S(null), z(!1);
  }
  function V(b) {
    T && (k.current[b.name] || T == null || T.addComponent(b), k.current[b.name] = b);
  }
  function G(b) {
    T && (k.current[b.name] && (T == null || T.removeComponent(b)), delete k.current[b.name]);
  }
  function H(b) {
    _ && _(b), b != null && b.activeComponents && Object.keys(k).forEach((W) => {
      var B;
      (B = b.activeComponents) != null && B.includes(W) || delete k.current[W];
    });
  }
  function j() {
    z(!0);
  }
  function M() {
    z(!1);
  }
  const X = q(() => ({
    hasProvider: !0,
    hasJoinedRoom: w,
    room: T,
    addComponent: V,
    removeComponent: G,
    activeComponents: k.current
  }), [T, f, l, o, n, k, w]);
  return /* @__PURE__ */ A.jsx(Ke.Provider, { value: X, children: s });
}
function Gt({ viewer: t, children: o, ...n }) {
  const { room: i, component: s, addComponent: d } = I("presence3dAutodesk"), [l, f] = F(null);
  return v(() => {
    if (!i || l || !t)
      return;
    const u = new Rt(t, n);
    d(u), f(Date.now());
  }, [i, t]), v(() => {
    !s && l && f(null);
  }, [s]), o ?? /* @__PURE__ */ A.jsx(A.Fragment, {});
}
function Qt({
  modelUrn: t,
  clientId: o,
  clientSecret: n,
  authUrl: i,
  initializeOptions: s,
  data: d,
  onDocumentLoadError: l,
  onDocumentLoadSuccess: f,
  onViewerInitialized: u,
  isAvatarsEnabled: c,
  isLaserEnabled: m,
  isNameEnabled: g,
  isMouseEnabled: y,
  avatarConfig: C,
  ..._
}) {
  const [w, z] = F(null), { hasJoinedRoom: T } = I("presence3dAutodesk"), S = i || "https://developer.api.autodesk.com/authentication/v2/token", ee = btoa(`${o}:${n}`), te = {
    // eslint-disable-next-line camelcase
    grant_type: "client_credentials",
    scope: "data:read bucket:read",
    ...d
  };
  v(() => {
    T && k();
  }, [T]);
  async function k() {
    let N = null;
    if (!window.Autodesk) {
      console.error("[Superviz] Autodesk not found");
      return;
    }
    await fetch(S, {
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded",
        Authorization: `Basic ${ee}`
      },
      body: new URLSearchParams(te).toString()
    }).then((L) => L.json()).then((L) => {
      const G = `urn:${btoa(t)}`, H = {
        env: "AutodeskProduction2",
        api: "streamingV2",
        accessToken: L.access_token,
        ...s
      };
      window.Autodesk.Viewing.Initializer(H, async () => {
        const j = document.getElementById("autodesk-content");
        if (!j) {
          console.error("[Superviz] Autodesk container not found");
          return;
        }
        N = new window.Autodesk.Viewing.GuiViewer3D(j), await N.start(), u && u({
          viewer: N,
          container: j
        }), window.Autodesk.Viewing.Document.load(G, U, Q);
      });
    });
    function U(L) {
      f && f(L);
      const V = L.getRoot().getDefaultGeometry();
      if (!V || !N)
        return;
      const G = {
        applyScaling: "meters"
      };
      N.loadDocumentNode(L, V, G).then(() => {
        N && z(N);
      }).catch((H) => {
        console.error("[SuperViz] Failed to load document node", H);
      });
    }
    function Q(L, V, G) {
      l && l(L, V, G), console.error("[SuperViz] Failed to load document", L, V, G);
    }
  }
  return /* @__PURE__ */ A.jsx(
    Gt,
    {
      viewer: w,
      isAvatarsEnabled: c,
      isLaserEnabled: m,
      isNameEnabled: g,
      isMouseEnabled: y,
      avatarConfig: C,
      children: /* @__PURE__ */ A.jsx("div", { id: "autodesk-content", ..._ })
    }
  );
}
function er({
  pin: t,
  children: o,
  onPinActive: n,
  onPinInactive: i,
  onMount: s,
  onUnmount: d,
  ...l
}) {
  const { room: f, component: u, addComponent: c } = I("comments"), [m, g] = F(null), y = {
    "pin-mode.active": n,
    "pin-mode.inactive": i,
    mount: s,
    unmount: d
  };
  return v(() => {
    u && Object.entries(y).forEach(([C, _]) => {
      u.unsubscribe(C, _), _ && u.subscribe(C, _);
    });
  }, [u, f, n, i, s, d]), v(() => {
    if (!f || m || !t)
      return;
    const C = new wt(t, { ...l });
    c(C), g(Date.now());
  }, [f, t]), v(() => {
    !u && m && g(null);
  }, [u]), o ?? /* @__PURE__ */ A.jsx(A.Fragment, {});
}
var fe = /* @__PURE__ */ ((t) => (t.INPUT = "field.input", t.BLUR = "field.blur", t.FOCUS = "field.focus", t.CHANGE = "field.change", t.KEYBOARD_INTERACTION = "field.keyboard-interaction", t))(fe || {});
function tr({
  onMount: t,
  onUnmount: o,
  disableOutline: n,
  disableRealtimeSync: i,
  fields: s,
  children: d,
  onContentChange: l,
  onContentSync: f
}) {
  const { room: u, component: c, addComponent: m } = I("formElements"), [g, y] = F(null), C = {
    mount: t,
    unmount: o
  };
  return v(() => {
    c && Object.entries(C).forEach(([_, w]) => {
      c.unsubscribe(_, w), w && c.subscribe(_, w);
    });
  }, [c, u, t, o, l, f]), v(() => {
    c && (Object.keys(c.fields).forEach((_) => {
      c.unsubscribe(`${fe.KEYBOARD_INTERACTION}-${_}`), c.unsubscribe(`${fe.INPUT}-${_}`), l && c.subscribe(`${fe.KEYBOARD_INTERACTION}-${_}`, l), f && c.subscribe(`${fe.INPUT}-${_}`, f);
    }), Object.entries(C).forEach(([_, w]) => {
      c.unsubscribe(_, w), w && c.subscribe(_, w);
    }));
  }, [c, u, l, f]), v(() => {
    if (!u || g)
      return;
    const _ = new At({
      fields: s,
      disableOutline: n,
      disableRealtimeSync: i
    });
    m(_), y(Date.now());
  }, [u]), v(() => {
    !c && g && y(null);
  }, [c]), d ?? /* @__PURE__ */ A.jsx(A.Fragment, {});
}
function Wt({
  matterportSdkInstance: t,
  children: o,
  ...n
}) {
  const { room: i, component: s, addComponent: d } = I("presence3dMatterport"), [l, f] = F(null);
  return v(() => {
    if (!i || l || !t)
      return;
    const u = new Ft(
      t,
      n
    );
    d(u), f(Date.now());
  }, [i, t]), v(() => {
    !s && l && f(null);
  }, [s]), o ?? /* @__PURE__ */ A.jsx(A.Fragment, {});
}
function rr({
  isAvatarsEnabled: t,
  isLaserEnabled: o,
  isNameEnabled: n,
  avatarConfig: i,
  bundleUrl: s,
  matterportKey: d,
  onMpSdkLoaded: l,
  ...f
}) {
  const u = J(null), [c, m] = F(null);
  v(() => {
    u.current && g();
  }, [s, u.current]);
  async function g() {
    if (c)
      return;
    const y = document.getElementById("showcase"), C = y.contentWindow;
    if (y.setAttribute("src", s), !C) {
      console.error("[SuperViz] Matterport Showcase iframe not found");
      return;
    }
    await new Promise((_) => {
      const w = async () => {
        const z = await C.MP_SDK.connect(C, d);
        m(z), l && l({
          matterportSdkInstance: z,
          showcaseWindow: u.current
        }), _(!0), y.removeEventListener("load", w);
      };
      y.addEventListener("load", w);
    });
  }
  return /* @__PURE__ */ A.jsx(
    Wt,
    {
      matterportSdkInstance: c,
      isAvatarsEnabled: t,
      isLaserEnabled: o,
      isNameEnabled: n,
      avatarConfig: i,
      children: /* @__PURE__ */ A.jsx("iframe", { ref: u, id: "showcase", ...f })
    }
  );
}
function nr({
  children: t,
  elementId: o,
  onMount: n,
  onUnmount: i,
  transform: s,
  ...d
}) {
  const [l, f] = F(null), { room: u, component: c, addComponent: m } = I(
    "presence"
  ), g = {
    mount: n,
    unmount: i
  };
  return v(() => {
    c && Object.entries(g).forEach(([y, C]) => {
      c.unsubscribe(y, C), C && c.subscribe(y, C);
    });
  }, [c, u, n, i]), v(() => {
    s && (c == null || c.transform(s));
  }, [s]), v(() => {
    var _;
    if (!u || l || !document.getElementById(o))
      return;
    const y = (_ = d.callbacks) == null ? void 0 : _.onGoToPresence, C = new St(o, {
      callbacks: { onGoToPresence: y }
    });
    m(C), f(Date.now());
  }, [u, o]), v(() => {
    !c && l && f(null);
  }, [c]), t ?? /* @__PURE__ */ A.jsx(A.Fragment, {});
}
function or({ onStateChange: t, onMount: o, onUnmount: n }) {
  const { room: i, component: s, addComponent: d } = I("realtime"), [l, f] = F(null);
  return v(() => {
    if (!i || l)
      return;
    const u = new Ot();
    d(u), f(Date.now()), t && u.subscribe(
      It.REALTIME_STATE_CHANGED,
      t
    ), o && o();
  }, [i]), v(() => {
    !s && l && (f(null), n && n());
  }, [s]), /* @__PURE__ */ A.jsx(A.Fragment, {});
}
function ir({
  scene: t,
  camera: o,
  player: n,
  children: i,
  ...s
}) {
  const { room: d, component: l, addComponent: f } = I("presence3dThreejs"), [u, c] = F(null);
  return v(() => {
    if (!d || u || !t || !o || !n)
      return;
    const m = new $t(t, o, n, { ...s });
    f(m), c(Date.now());
  }, [d, t]), v(() => {
    !l && u && c(null);
  }, [l]), i ?? /* @__PURE__ */ A.jsx(A.Fragment, {});
}
const Je = (t) => ({
  [x.DESTROY]: t.onDestroy,
  [Lt.FRAME_DIMENSIONS_UPDATE]: t.onFrameDimensionsChange,
  [x.MEETING_WAITING_FOR_HOST]: t.onWaitingForHostChange,
  [x.MEETING_CONNECTION_STATUS_CHANGE]: t.onConnectionStatusChange,
  [x.MEETING_STATE_UPDATE]: t.onMeetingStateChange,
  [x.MEETING_SAME_PARTICIPANT_ERROR]: t.onSameAccountError,
  [x.MEETING_DEVICES_CHANGE]: t.onDevicesStateChange,
  [x.MEETING_HOST_CHANGE]: t.onHostChange,
  [x.MEETING_HOST_AVAILABLE]: t.onHostAvailable,
  [x.MEETING_NO_HOST_AVAILABLE]: t.onNoHostAvailable,
  [x.MEETING_START]: t.onMeetingStart,
  [x.MEETING_PARTICIPANT_JOINED]: t.onParticipantJoin,
  [x.MY_PARTICIPANT_JOINED]: t.onLocalParticipantJoin,
  [x.MEETING_PARTICIPANT_LEFT]: t.onParticipantLeave,
  [x.MY_PARTICIPANT_LEFT]: t.onLocalParticipantLeave,
  [x.MEETING_PARTICIPANT_LIST_UPDATE]: t.onParticipantListChange,
  [x.MEETING_PARTICIPANT_AMOUNT_UPDATE]: t.onParticipantAmountChange,
  [x.MEETING_KICK_PARTICIPANTS]: t.onKickAllParticipants,
  [x.MEETING_KICK_PARTICIPANT]: t.onKickLocalParticipant,
  mount: t.onMount,
  unmount: t.onUnmount
});
function ar(t) {
  const {
    onMeetingStart: o,
    onDestroy: n,
    onFrameDimensionsChange: i,
    onWaitingForHostChange: s,
    onConnectionStatusChange: d,
    onMeetingStateChange: l,
    onSameAccountError: f,
    onDevicesStateChange: u,
    onHostChange: c,
    onHostAvailable: m,
    onNoHostAvailable: g,
    onParticipantJoin: y,
    onLocalParticipantJoin: C,
    onParticipantLeave: _,
    onLocalParticipantLeave: w,
    onParticipantListChange: z,
    onParticipantAmountChange: T,
    onKickAllParticipants: S,
    onKickLocalParticipant: ee,
    onMount: te,
    onUnmount: k
  } = t, { room: N, component: U, addComponent: Q } = I("videoConference"), [L, V] = F(null), [G, H] = F(null);
  v(() => {
    if (!N || L)
      return;
    const M = new Dt(t);
    j(M, t), Q(M), V(Date.now());
  }, [N]), v(() => {
    const M = Je(t);
    !U || Be(G, M) || j(U, t);
  }, [
    U,
    o,
    n,
    i,
    s,
    d,
    l,
    f,
    u,
    c,
    m,
    g,
    y,
    C,
    _,
    w,
    z,
    T,
    S,
    ee,
    te,
    k
  ]), v(() => {
    !U && L && V(null);
  }, [U]);
  function j(M, X) {
    const b = Je(X);
    Object.entries(b).forEach(([W, B]) => {
      X[W] || M.unsubscribe(W), B && M.subscribe(W, B);
    }), H(b);
  }
  return /* @__PURE__ */ A.jsx(A.Fragment, {});
}
function sr({ position: t, styles: o, onMount: n, onUnmount: i, ...s }) {
  const { room: d, component: l, addComponent: f } = I("whoIsOnline"), [u, c] = F(null), m = {
    mount: n,
    unmount: i
  };
  return v(() => {
    l && Object.entries(m).forEach(([g, y]) => {
      l.unsubscribe(g, y), y && l.subscribe(g, y);
    });
  }, [l, d, n, i]), v(() => {
    if (!d || u)
      return;
    const g = new jt({ position: t, styles: o, ...s });
    f(g), c(Date.now());
  }, [d]), v(() => {
    !l && u && c(null);
  }, [l]), /* @__PURE__ */ A.jsx(A.Fragment, {});
}
function ur() {
  const { component: t, ...o } = I("presence3dAutodesk");
  return q(() => t ? {
    isReady: !0,
    follow: (n) => {
      t.follow(n);
    },
    goTo: (n) => {
      t.goTo(n);
    }
  } : {
    isReady: !1,
    follow: () => {
    },
    goTo: () => {
    }
  }, [o.room, o.activeComponents, t]);
}
function cr({ autodeskInstance: t }) {
  const { room: o } = I(), n = J(!1), i = J(null);
  return v(() => {
    var s;
    !o && n.current && (n.current = !1, (s = i.current) == null || s.destroy(), i.current = null);
  }, [o]), q(() => {
    if (!t)
      return {
        pin: null,
        destroy: () => {
        }
      };
    if (!n.current) {
      n.current = !0;
      const s = new Ct(t);
      i.current = s;
    }
    return {
      pin: i == null ? void 0 : i.current,
      destroy: () => {
        var s;
        (s = i == null ? void 0 : i.current) == null || s.destroy(), i.current = null;
      }
    };
  }, [t, o, i.current]);
}
function lr({ canvasId: t, onGoToPin: o }) {
  const { room: n } = I(), i = J(!1), s = J(null);
  function d(l) {
    o && o(l);
  }
  if (v(() => {
    var l;
    !n && i.current && (i.current = !1, (l = s.current) == null || l.destroy(), s.current = null);
  }, [n]), !t || !document.getElementById(t))
    return {
      pin: null,
      destroy: () => {
      }
    };
  if (!i.current) {
    i.current = !0;
    const l = new xt(t, {
      onGoToPin: d
    });
    s.current = l;
  }
  return {
    pin: s.current,
    destroy: () => {
      var l;
      (l = s.current) == null || l.destroy(), s.current = null;
    }
  };
}
function fr() {
  const { component: t, ...o } = I("comments");
  return q(() => t ? {
    isReady: !0,
    openThreads: () => {
      t.openThreads();
    },
    closeThreads: () => {
      t.closeThreads();
    },
    enable: () => {
      t.enable();
    },
    disable: () => {
      t.disable();
    }
  } : {
    isReady: !1,
    openThreads: () => {
    },
    closeThreads: () => {
    },
    enable: () => {
    },
    disable: () => {
    }
  }, [t, o.room, o.activeComponents]);
}
let ae = null;
function dr({ containerId: t, ...o }) {
  const { room: n } = I(), [i, s] = F(!1);
  return v(() => {
    !n && i && s(!1);
  }, [n]), q(() => !t || !document.getElementById(t) ? {
    pin: null,
    destroy: () => {
    }
  } : (ae || (ae = new Nt(t, o), s(!0)), {
    pin: ae,
    destroy: () => {
      ae == null || ae.destroy(), s(!1);
    }
  }), [t, n, i]);
}
function pr() {
  const { component: t, ...o } = I("presence3dMatterport");
  return q(() => t ? {
    isReady: !0,
    follow: (n) => {
      t.follow(n);
    },
    goTo: (n) => {
      t.goTo(n);
    }
  } : {
    isReady: !1,
    follow: () => {
    },
    goTo: () => {
    }
  }, [o.room, o.activeComponents, t]);
}
function mr({ matterportInstance: t, showcaseWindow: o }) {
  const { room: n } = I(), i = J(!1), s = J(null);
  return v(() => {
    var d;
    !n && i.current && (i.current = !1, (d = s.current) == null || d.destroy(), s.current = null);
  }, [n]), q(() => {
    if (!o || !t)
      return {
        pin: null,
        destroy: () => {
        }
      };
    if (!i.current) {
      i.current = !0;
      const d = new kt(t, o);
      s.current = d;
    }
    return {
      pin: s.current,
      destroy: () => {
        var d;
        (d = s.current) == null || d.destroy(), s.current = null;
      }
    };
  }, [o, t]);
}
function vr() {
  const [t, o] = F(!1), { component: n, ...i } = I("realtime"), s = J({});
  v(() => {
    n && (n.subscribe("realtime-component.state-changed", (c) => {
      o(c === Mt.STARTED);
    }), Object.keys(s.current).length && (Object.entries(s.current).forEach(([c, m]) => {
      m.forEach((g) => {
        n.subscribe(c, g);
      });
    }), s.current = {}));
  }, [n, s.current]);
  const d = Ee(
    (c, m) => {
      if (!n) {
        const g = s.current[c] || [];
        s.current[c] = g.includes(m) ? g : [...g, m];
        return;
      }
      n.subscribe(c, m);
    },
    [n, i, s.current]
  ), l = Ee(
    (c, m) => {
      t && n.publish(c, m);
    },
    [n, i, t]
  ), f = Ee(
    (c, m) => {
      t && n.unsubscribe(c, m);
    },
    [n, i, t]
  ), u = Ee(
    async (c) => t ? await n.fetchHistory(c) : (console.warn("[SuperViz] Realtime component is not ready - try again later"), Promise.resolve(null)),
    [n, i, t]
  );
  return q(() => ({
    isReady: t,
    publish: l,
    subscribe: d,
    unsubscribe: f,
    fetchHistory: u
  }), [n, i, t]);
}
function gr() {
  const { component: t, ...o } = I("presence3dThreejs");
  return q(() => t ? {
    isReady: !0,
    follow: (n) => {
      t.follow(n);
    },
    goTo: (n) => {
      t.goTo(n);
    }
  } : {
    isReady: !1,
    follow: () => {
    },
    goTo: () => {
    }
  }, [o.room, o.activeComponents, t]);
}
function Er({
  scene: t,
  renderer: o,
  camera: n,
  player: i,
  controls: s
}) {
  const { room: d } = I(), l = J(!1), f = J(null);
  return v(() => {
    var u;
    !d && l.current && (l.current = !1, (u = f.current) == null || u.destroy(), f.current = null);
  }, [d]), q(() => {
    if (!t || !o || !n)
      return {
        pin: null,
        destroy: () => {
        }
      };
    if (!l.current) {
      l.current = !0;
      const u = new Vt(t, o, n, i, s);
      f.current = u;
    }
    return {
      pin: f.current,
      destroy: () => {
        var u;
        (u = f.current) == null || u.destroy(), f.current = null;
      }
    };
  }, [t, o, n, i, s]);
}
function Tr() {
  const { component: t, ...o } = I("videoConference");
  return q(() => t ? {
    isReady: !0,
    toggleMeetingSetup: () => {
      t.toggleMeetingSetup();
    },
    toggleMicrophone: () => {
      t.toggleMicrophone();
    },
    toggleCam: () => {
      t.toggleCam();
    },
    toggleScreenShare: () => {
      t.toggleScreenShare();
    },
    toggleChat: () => {
      t.toggleChat();
    },
    toggleTranscript: () => {
      t.toggleTranscript();
    },
    hangUp: () => {
      t.hangUp();
    }
  } : {
    isReady: !1,
    toggleMeetingSetup: () => {
    },
    toggleMicrophone: () => {
    },
    toggleCam: () => {
    },
    toggleScreenShare: () => {
    },
    toggleChat: () => {
    },
    toggleTranscript: () => {
    },
    hangUp: () => {
    }
  }, [o.room, o.activeComponents, t]);
}
function Yt(t) {
  if (t = t.replace("#", ""), t.length === 6) {
    const o = parseInt(t.substring(0, 2), 16), n = parseInt(t.substring(2, 4), 16), i = parseInt(t.substring(4, 6), 16);
    return `${o} ${n} ${i}`;
  } else if (t.startsWith("rgb(") && t.endsWith(")")) {
    const o = t.substring(4, t.length - 1).split(",");
    return `${o[0].trim()} ${o[1].trim()} ${o[2].trim()}`;
  } else
    return t;
}
function hr(t) {
  const o = {};
  for (const [n, i] of Object.entries(t))
    o[n] = Yt(i);
  return o;
}
export {
  Gt as AutodeskPresence,
  Qt as AutodeskViewer,
  er as Comments,
  fe as FieldEvents,
  tr as FormElements,
  rr as MatterportIframe,
  Wt as MatterportPresence,
  nr as MousePointers,
  or as Realtime,
  Zt as SuperVizRoomProvider,
  ir as ThreeJsPresence,
  ar as VideoConference,
  sr as WhoIsOnline,
  hr as createTheme,
  ur as useAutodesk,
  cr as useAutodeskPin,
  lr as useCanvasPin,
  fr as useComments,
  dr as useHTMLPin,
  pr as useMatterport,
  mr as useMatterportPin,
  vr as useRealtime,
  gr as useThree,
  Er as useThreeJsPin,
  Tr as useVideo
};
